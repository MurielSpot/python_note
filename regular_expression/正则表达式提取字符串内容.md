## 正则表达式中常用字符
https://www.cnblogs.com/tina-python/p/5508402.html

**普通字符和11个元字符：**

| 普通字符 | 匹配自身                                                     | abc                  | abc         |
| -------- | ------------------------------------------------------------ | -------------------- | ----------- |
| .        | 匹配任意除换行符"\n"外的字符(在DOTALL模式中也能匹配换行符    | a.c                  | abc         |
| \        | 转义字符，使后一个字符改变原来的意思                         | a\.c;a\\c            | a.c;a\c     |
| *        | 匹配前一个字符0或多次                                        | abc*                 | ab;abccc    |
| +        | 匹配前一个字符1次或无限次                                    | abc+                 | abc;abccc   |
| ?        | 匹配一个字符0次或1次                                         | abc?                 | ab;abc      |
| ^        | 匹配字符串开头。在多行模式中匹配每一行的开头                 | ^abc                 | abc         |
| $        | 匹配字符串末尾，在多行模式中匹配每一行的末尾                 | abc$                 | abc         |
| \|       | 或。匹配\|左右表达式任意一个，从左到右匹配，如果\|没有包括在()中，则它的范围是整个正则表达式 | abc\|def             | abcdef      |
| {}       | {m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次 | ab{1,2}c             | abcabbc     |
| []       | 字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。 | a[bcd]e              | abeaceade   |
| ()       | 被括起来的表达式将作为分组，从表达式左边开始没遇到一个分组的左括号“（”，编号+1.分组表达式作为一个整体，可以后接数量词。表达式中的\|仅在该组中有效。 | (abc){2}a(123\|456)c | abcabca456c |

这里需要强调一下反斜杠\的作用：

- 反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符）
- 反斜杠后边跟普通字符实现特殊功能；（即预定义字符）
- 引用序号对应的字组所匹配的字符串。

**预定义字符集（可以写在字符集[...]中）** 

| \d   | 数字:[0-9]                                                   | a\bc          | a1c             |
| ---- | ------------------------------------------------------------ | ------------- | --------------- |
| \D   | 非数字:[^\d]                                                 | a\Dc          | abc             |
| \s   | 匹配任何空白字符:[<空格>\t\r\n\f\v]                          | a\sc          | a c             |
| \S   | 非空白字符:[^\s]                                             | a\Sc          | abc             |
| \w   | 匹配包括下划线在内的任何字字符:[A-Za-z0-9_]                  | a\wc          | abc             |
| \W   | 匹配非字母字符，即匹配特殊字符                               | a\Wc          | a c             |
| \A   | 仅匹配字符串开头,同^                                         | \Aabc         | abc             |
| \Z   | 仅匹配字符串结尾，同$                                        | abc\Z         | abc             |
| \b   | 匹配\w和\W之间，即匹配单词边界匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 | \babc\ba\b!bc | 空格abc空格a!bc |
| \B   | [^\b]                                                        | a\Bbc         | abc             |

## 常用函数
search(pattern, string, flags=0)      在一个字符串中查找匹配

findall(pattern, string ,flags=0)     找到匹配，返回所有匹配部分的列表

sub(pattern, repl, string , count=0, flags=0)    将字符串中匹配正则表达式的部分替换为其他值

split(pattern, string ,maxsplit=0, flags=0)  根据匹配分割字符串，返回分隔符串组成的列表

### re.match()
re.match() 总是从字符串“开头”去匹配，并返回匹配的字符串的match对象。
```
import re
s='我不知道呀'
print(re.match(r'我',s))
#结果
<_sre.SRE_Match object; span=(0, 1), match='我'>
```
### re.search()

re.search()函数将对整个字符串进行搜索，并返回第一个匹配的字符串的match对象。

```
s='啊我不知道呀'
print(re.search(r'我',s))
#结果
<_sre.SRE_Match object; span=(1, 2), match='我'>
```

### re.findall()

re.findall()函数将返回一个所有匹配的字符串的字符串列表。
```
s='啊我不知道呀我要去取经了'
print(re.findall(r'我',s))
#结果
['我', '我']
```
## 匹配时pattern里的字符串用字符串变量代替的写法
re.'%s'%aStr 就可以用aStr里的字符作为pattern来匹配字符串了。
```
import re
pa=['为.?.?.?.?.?.?打电话','可能.?.?.?了.?.?.?假','不想.?.?说话并向你扔了']
s='''为潘玮柏疯狂打电话，怎么可能，肯定不是吴昕打的，
如果是吴昕，那她可能打了一个假电话，哦我猜想她的粉丝听了这个消息一定不想和你说话并向你扔了一只狗
'''
for i in pa:
    print(re.findall(r'%s'%i,s))
#输出
['为潘玮柏疯狂打电话']
['可能打了一个假']
['不想和你说话并向你扔了']
```

## 单个位置的字符串提取

这种情况我们可以使用(.+?)这个正则表达式来提取. 举例,一个字符串"a123b",如果我们想提取ab之间的值123,可以使用findall配合正则表达式,这样会返回一个包含所以符合情况的list,代码如下:

```
import re
str = "a123b"
print re.findall(r"a(.+?)b",str)#
输出['123']
```

## 贪婪和非贪婪匹配

如果我们有一个字符串”a123b456b”,如果我们想匹配a和最后一个b之间的所有值而非a和第一个出现的b之间的值,可以用?来控制正则贪婪和非贪婪匹配的情况. 代码如下:

```
import re
str = "a123b456b"

print re.findall(r"a(.+?)b", str)
#输出['123']#?控制只匹配0或1个,所以只会输出和最近的b之间的匹配情况

print re.findall(r"a(.+)b", str)
#输出['123b456']

print re.findall(r"a(.*)b", str)
#输出['123b456']
```

## 多行匹配

如果你要多行匹配，那么需要加上re.S和re.M标志. 加上re.S后, .将会匹配换行符，默认.不会匹配换行符. 代码如下:

```
str = "a23b\na34b"

re.findall(r"a(\d+)b.+a(\d+)b", str)
#输出[]
#因为不能处理str中间有\n换行的情况

re.findall(r"a(\d+)b.+a(\d+)b", str, re.S)
#s输出[('23', '34')]
```
加上re.M后,^$标志将会匹配每一行，默认^和$只会匹配第一行. 代码如下:

```
str = "a23b\na34b"

re.findall(r"^a(\d+)b", str)
#输出['23']

re.findall(r"^a(\d+)b", str, re.M)
#输出['23', '34']
```
