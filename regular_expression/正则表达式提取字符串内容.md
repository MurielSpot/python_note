## 常用函数
search(pattern, string, flags=0)      在一个字符串中查找匹配

findall(pattern, string ,flags=0)     找到匹配，返回所有匹配部分的列表

sub(pattern, repl, string , count=0, flags=0)    将字符串中匹配正则表达式的部分替换为其他值

split(pattern, string ,maxsplit=0, flags=0)  根据匹配分割字符串，返回分隔符串组成的列表

## 单个位置的字符串提取

这种情况我们可以使用(.+?)这个正则表达式来提取. 举例,一个字符串"a123b",如果我们想提取ab之间的值123,可以使用findall配合正则表达式,这样会返回一个包含所以符合情况的list,代码如下:

```
import re
str = "a123b"
print re.findall(r"a(.+?)b",str)#
输出['123']
```

## 贪婪和非贪婪匹配

如果我们有一个字符串”a123b456b”,如果我们想匹配a和最后一个b之间的所有值而非a和第一个出现的b之间的值,可以用?来控制正则贪婪和非贪婪匹配的情况. 代码如下:

```
import re
str = "a123b456b"

print re.findall(r"a(.+?)b", str)
#输出['123']#?控制只匹配0或1个,所以只会输出和最近的b之间的匹配情况

print re.findall(r"a(.+)b", str)
#输出['123b456']

print re.findall(r"a(.*)b", str)
#输出['123b456']
```

## 多行匹配

如果你要多行匹配，那么需要加上re.S和re.M标志. 加上re.S后, .将会匹配换行符，默认.不会匹配换行符. 代码如下:

```
str = "a23b\na34b"

re.findall(r"a(\d+)b.+a(\d+)b", str)
#输出[]
#因为不能处理str中间有\n换行的情况

re.findall(r"a(\d+)b.+a(\d+)b", str, re.S)
#s输出[('23', '34')]
```
加上re.M后,^$标志将会匹配每一行，默认^和$只会匹配第一行. 代码如下:

```
str = "a23b\na34b"

re.findall(r"^a(\d+)b", str)
#输出['23']

re.findall(r"^a(\d+)b", str, re.M)
#输出['23', '34']
```
